# 遊戲控制器測試模組整合架構建議

## 模組劃分與檔案架構

為了便於維護與擴充，可以將每種手把測試功能獨立成模組（獨立的 Python 檔案），並採用統一的目錄架構。建議建立一個專門的\*\*`tests/`資料夾**來放置所有測試模組，以及一個**共用模組資料夾\*\*存放公用的程式碼（例如控制器輸入處理、工具函式等）。各測試模組彼此獨立，透過匯入共用模組使用共用功能。以下是一個可能的檔案與目錄結構範例：

```plaintext
project/
├── tests/
│   ├── connection_test.py         # 手把連接測試（裝置偵測與連線確認）
│   ├── button_smash_test.py       # Button Smash 連打點擊測試
│   ├── reaction_time_test.py      # 簡單反應時間測試（紅色圓圈出現反應）
│   ├── prediction_reaction_test.py# 可預測反應時間測試（倒數計時球體）
│   ├── choice_accuracy_test.py    # 選擇反應（方向按鍵準確度）測試
│   ├── analog_move_test.py        # 類比搖桿移動精準度測試 (Fitts 定律)
│   └── path_follow_test.py        # 路徑追蹤/轉角路徑測試（沿指定路徑移動）
├── common/                        # 共用模組
│   ├── controller_input.py        # 手把輸入處理核心（裝置偵測、事件監聽）
│   ├── utils.py                   # 工具函式（如計時、亂數、共用設定等）
│   └── config.py                  # 參數設定（如測試時長、閾值等）
├── data/
│   ├── results/                   # 測試結果輸出(JSON)
│   └── images/                    # 圖片輸出（如路徑軌跡圖）
├── run_all_tests.sh               # 一鍵執行所有測試的腳本
└── README.md
```

上述架構中，每個測試都有獨立的 Python 檔案，彼此**模組化**且低度耦合，方便日後新增或修改測試項目。例如，目前專案中已有的測試腳本（如`button_reaction-time.py`簡單反應時間測試、`analog_move.py`類比搖桿移動測試等）就可以各自成為一個模組。共用模組（如手把輸入處理`controller_input.py`）則集中管理，以供各測試調用。

**檔名與匯入：** 為了能在程式中匯入這些測試模組，請確保檔名符合 Python 模組命名規範（例如使用底線 `_` 而非連字號 `-`）。可以在`tests/`資料夾內加入`__init__.py`檔案，使其成為一個 package，如此主程式或腳本可以使用 `from tests import reaction_time_test` 等方式匯入各測試模組。

**主控流程：** 可以設計一個主控的 Python 腳本（或直接透過 `.sh` 腳本調用），按照順序依次執行各個測試模組。每個測試模組應提供一個統一的介面（例如都定義一個 `run_test(user_id)` 函式或在執行時接受參數）以便主控程序呼叫。這樣能確保各模組組合在一起時流程順暢，不需人工介入切換。

## 測試資料儲存格式（JSON 與圖片）

為方便日後分析與比較，所有測試結果建議**統一以 JSON 格式儲存**，每位使用者每項測試產生一個 JSON 檔案。JSON 結構設計應該清晰描述測試結果的重點指標，例如：點擊次數、反應時間、錯誤率、完成時間等。若同一測試包含多次嘗試或多輪數據，可在 JSON 中使用陣列紀錄每回合的結果。建議每個 JSON 檔都至少包含以下欄位：

* **user\_id：** 使用者或受測者的識別碼（例如 `"user001"`），方便區分不同受測者的資料。
* **test\_name：** 測試項目名稱（例如 `"ButtonSmash"`、`"ReactionTime"`），或以程式代號表示，用於識別測試種類。
* **timestamp：** 測試進行時間或完成時間（ISO 格式字串），方便日後排序或比對。
* **metrics：** 一個物件，內含該測試的重要指標數值。不同測試有不同指標，舉例：

  * *Button Smash 測試：* `total_clicks`（在限定時間內總按壓次數）、`duration_seconds`（測試持續秒數，如5秒）、`clicks_per_second`（平均每秒點擊數）。
  * *反應時間測試：* `trials`（每次刺激的反應時間列表，單位毫秒）、`average_reaction_ms`（平均反應時間）、`missed_count`（漏按次數，如有的話）。
  * *選擇反應/按鍵準確度測試：* `correct_count`（正確反應次數）、`error_count`（按錯按鍵次數）、`average_reaction_ms`（平均反應時間）、`error_rate`（錯誤率％）。
  * *路徑追蹤測試：* `completion_time_ms`（完成路徑所花時間）、`out_of_bounds_count`（偏離路徑次數）、`corner_miss_count`（轉角未順利通過的次數）等。
* **details（選擇性）：** 如有需要，可加入更細節的資料，例如每次嘗試的時間戳、路徑座標軌跡數據等。這部分可以視需求紀錄，便於更深入的分析。

例如，一份簡化的 JSON 範例如下：

```json
{
  "user_id": "user001",
  "test_name": "ButtonSmash",
  "timestamp": "2025-07-26T19:00:00Z",
  "metrics": {
    "total_clicks": 48,
    "duration_seconds": 5,
    "clicks_per_second": 9.6
  }
}
```

每個測試完成後，程式應自動將結果序列化為 JSON 存檔至`data/results/`目錄下（檔名可結合使用者ID與測試名稱，如`user001_ButtonSmash.json`）。儲存時記得**確保文件正確關閉**，避免資料遺失。

若某項測試會產生視覺化結果（例如路徑追蹤測試可能需要輸出使用者行走路徑的圖形），則**以圖片檔案存檔**（如 PNG 圖片）。圖片檔建議存於`data/images/`目錄下，並以**使用者ID+測試名稱**為檔名前綴（例如`user001_path_follow.png`）。對於這類測試，可在 JSON 資料中加入一個欄位記錄對應的圖片檔名稱或路徑（例如 `"image": "images/user001_path_follow.png"`），以便日後對照。如果測試需要保存多張圖片（如每回合一張軌跡圖），可以存成列表或在檔名中加入序號。

總之，JSON 文字紀錄數值，圖片保存視覺結果，兩者結合提供完整的測試資料。使用 JSON 的好處是**格式輕便、易於被其他分析工具讀取**，後續可以很方便地將不同使用者或不同測試的 JSON 匯入進行統計分析或繪圖。

## 無障礙（色盲友善）設計建議

在介面設計與測試圖形呈現上，務必考慮**色覺障礙（色盲）使用者的可辨識性**。研究顯示約有 8% 的男性與 0.5% 的女性存在色覺缺陷（多為紅綠色弱/色盲），因此我們在設計刺激顏色或圖形時應避免使用容易混淆的配色。以下是具體建議：

* **避免紅色與綠色直接搭配：** 紅/綠組合是色盲中最常見難以區分的配對。如果測試中需要用顏色區分狀態，盡量不要僅靠紅色對比綠色。例如「正確/錯誤」不要只用紅綠燈顏色來表示。如果不得不使用紅色和綠色，請務必在**亮度或色調**上拉開差距（例如使用**淺綠色**搭配**深紅色**），以增加區別度。

* **採用色盲友好的配色組合：** 推薦使用對色盲相對友善的顏色搭配，例如**藍色/橘色**或**藍色/紅色**的組合。研究指出藍/橘是一組常見且對大多數色盲者友善的顏色組合，藍/紅或藍/棕的對比在色盲者眼中區別也相對明顯。原因在於**藍色**對於紅綠色盲者而言仍能被辨識為藍色。因此，若需要多種顏色區分不同狀態，藍、橘、紫等組合通常比紅綠組合更安全。

* **使用多元訊息傳達：** 別讓顏色成為傳遞資訊的唯一方式！除了色彩，還應輔以**文字標籤、圖示符號或樣式差異**來區分不同狀態。例如，在反應時間測試中，如果使用紅色圓形作為刺激，也可以加入文字提示（如「按下按鍵！」）或不同形狀的圖案來輔助；又或者在路徑測試的起終點使用不同形狀的標記，而不僅僅依靠顏色區分。這樣即使使用者分不清某些色彩，也能透過其他線索理解資訊。

* **參考色盲模擬與配色工具：** 在設計介面時，可使用**色盲模擬工具**（例如開源的 Color Oracle 模擬器）來檢視我們的測試畫面在各類色覺缺陷下的效果。同時，也建議利用線上配色資源找出安全的色票組合，例如 **Adobe Color 無障礙色輪**（Adobe Color Accessibility Tools）或 **ColorBrewer** 色彩方案等工具，這些工具可以提供已針對各種色盲類型測試過的色彩組合，確保選擇的顏色彼此區別明顯。透過這些方法，我們可以在維持美觀的同時，保障色覺障礙者也能順利地進行測試。

總而言之，介面設計應盡量做到**高對比度**、**低混淆度**，並**多重編碼訊息**（顏色搭配文字或形狀）來提升無障礙程度，確保所有使用者都能清楚辨識測試中的提示與反饋。

## 範例 `.sh` 腳本：一次執行所有測試

下面提供一個範例 Shell 腳本 (`run_all_tests.sh`) 的內容範例，示範如何一次執行所有測試項目並自動儲存結果。此腳本接受一個參數作為**使用者 ID**，依序執行各個測試模組，並將輸出結果保存到預定路徑下：

```bash
#!/bin/bash
# 用法: ./run_all_tests.sh <使用者ID>
USER_ID=$1

# 若未提供參數，提示用法並退出
if [ -z "$USER_ID" ]; then
  echo "用法: $0 <使用者ID>"
  exit 1
fi

# 建立結果輸出目錄 (以使用者ID命名) 
OUTPUT_DIR="data/results/$USER_ID"
IMAGE_DIR="data/images/$USER_ID"
mkdir -p "$OUTPUT_DIR" "$IMAGE_DIR"

echo "開始執行所有測試 (使用者: $USER_ID)..."

# 1. 手把連接測試
python3 tests/connection_test.py --user $USER_ID --out "$OUTPUT_DIR/connection.json"
echo "手把連接測試完成。結果已儲存至 $OUTPUT_DIR/connection.json"

# 2. Button Smash 連打測試
python3 tests/button_smash_test.py --user $USER_ID --out "$OUTPUT_DIR/button_smash.json"
echo "Button Smash 測試完成。結果已儲存至 $OUTPUT_DIR/button_smash.json"

# 3. 簡單反應時間測試 (紅圈出現反應)
python3 tests/reaction_time_test.py --user $USER_ID --out "$OUTPUT_DIR/reaction_time.json"
echo "簡單反應時間測試完成。結果已儲存至 $OUTPUT_DIR/reaction_time.json"

# 4. 預測反應時間測試 (倒數計時球體)
python3 tests/prediction_reaction_test.py --user $USER_ID --out "$OUTPUT_DIR/prediction_reaction.json"
echo "預測反應時間測試完成。結果已儲存至 $OUTPUT_DIR/prediction_reaction.json"

# 5. 選擇反應/按鍵準確度測試
python3 tests/choice_accuracy_test.py --user $USER_ID --out "$OUTPUT_DIR/choice_accuracy.json"
echo "選擇反應測試完成。結果已儲存至 $OUTPUT_DIR/choice_accuracy.json"

# 6. 類比搖桿移動精準度測試
python3 tests/analog_move_test.py --user $USER_ID --out "$OUTPUT_DIR/analog_move.json"
echo "類比搖桿移動測試完成。結果已儲存至 $OUTPUT_DIR/analog_move.json"

# 7. 路徑追蹤/轉角路徑測試
python3 tests/path_follow_test.py --user $USER_ID --out "$OUTPUT_DIR/path_follow.json" \
                                  --image_dir "$IMAGE_DIR"
echo "路徑追蹤測試完成。結果已儲存至 $OUTPUT_DIR/path_follow.json，軌跡圖儲存於 $IMAGE_DIR/"

echo "所有測試皆完成！請查看 $OUTPUT_DIR 以取得結果。"
```

**腳本說明：**

* 前半部先檢查是否有提供使用者 ID，然後建立對應的輸出資料夾（區分結果 JSON 檔與圖片檔路徑）。
* 依序執行各測試模組的 Python 腳本。使用 `--user` 參數將使用者ID傳給程式（程式可利用該ID來命名輸出檔案或寫入JSON）。使用 `--out` 指定結果輸出檔路徑，確保各模組將結果儲存在正確位置。某些測試如果會產生多個檔案（例如圖片），也可以透過參數傳入圖片輸出資料夾路徑（如上例的 `--image_dir`）。
* 在每項測試執行完畢後，都用 `echo` 提示目前測試完成並指出結果儲存的位置，以方便操作人員確認。
* 所有測試完成後，列印總結訊息。這樣的腳本讓操作人員只需執行一次指令，就能串聯起所有測試項目依序運行，減少手動介入的麻煩。

開發人員可以根據實際需要調整此腳本內容。例如，如果需要在測試之間給受測者休息或提示，可以在相鄰指令間加入 `read -p "按 Enter 繼續下一測試..."` 等暫停指令，讓使用者決定何時開始下一項測驗。

> **備註：** 如果使用 **uv** 環境來執行（如 README 中所示），腳本中的 Python 呼叫可替換為 `uv run python ...` 模式。不過在 `.sh` 腳本中直接使用系統中的 Python 直譯器也能達到相同效果，視團隊偏好決定即可。

## 其他注意事項（效能、互動性、參數等）

在整合多個測試模組時，還有一些額外的細節需要注意：

* **裝置初始化與重用：** 建議在整套測試開始之前就執行手把**連接測試或裝置選擇步驟**（如 `connection_test.py`），讓使用者選定要使用的控制器。選擇完成後，可以將選擇結果（裝置編號或ID）傳遞給後續的測試模組，避免每個測試重複要求使用者選擇裝置。實作上，可以在第一次選擇後將裝置ID寫入共用的設定檔或環境變數，後續模組啟動時讀取，這樣使用者只需配對一次手把。

* **效能與資源管理：** 多項測試連續執行時，注意釋放資源以維持效能穩定。例如何時關閉 Pygame 視窗、退出遊戲迴圈等：在每個測試模組完成後，應適當地呼叫 `pygame.quit()` 或關閉 Tkinter 視窗，以免佔用記憶體或造成下一測試的衝突。由於 `.sh` 腳本是逐個啟動獨立的 Python 進程，通常每個模組結束時該進程就會結束，資源會隨之釋放。但如果未來改為單一程式串聯多測試（非獨立進程），更需要確保各模組正確清理（例如將監聽執行緒停止等）才能啟動下一個。

* **時間控制與同步：** 確保各測試的計時機制精確可靠。例如反應時間以毫秒計，路徑計時以秒計，可能需要使用高精度計時函式（`time.time()`或`pygame.time.get_ticks()`等）。另外，如果在一個測試中啟用了執行緒或計時器，結束時要停用它們，避免干擾下一測試。

* **使用者互動提示：** 在各測試開始前後，提供清楚的提示或倒數。例如：「準備開始$測試名稱$...3、2、1」的倒數，或「測試結束，請鬆開手把等待下一項」等。這可以透過程式在開始/結束時顯示簡短訊息或音效來實現。也可以在不同測試之間加入**短暫的延遲或等待**，讓使用者有時間緩衝。良好的互動提示可提升使用者體驗，避免使用者在測試交替時困惑。

* **參數初始化與設定：** 將各測試的重要參數集中管理（可使用上述的`common/config.py`或設定檔）。例如：

  * Button Smash 測試的時長（如5秒或10秒）、
  * 反應時間測試的刺激停留時間、間隔時間、
  * 路徑追蹤測試的路徑寬度、彎曲角度、檢查點位置等，
  * 這些都可以在設定中調整，而不用深入程式碼修改。採用集中設定能確保調整參數時的**一致性**，也方便依據教授回饋快速修改實驗條件。

* **結果檢視與日後分析：** 完成所有測試後，可以開發一個簡單的彙總腳本或功能，自動讀取`data/results/`中某位使用者的所有 JSON 檔，生成一份概要報告。例如計算出該使用者的各項指標摘要，或將多項測試結果整合呈現在一個報表中（可能以 Markdown、CSV 或圖表呈現）。這在有大量受測者時會很實用。雖然這不屬於前述測試流程的一部分，但提前設計資料格式和存放架構時可以考慮到這點，使後續分析更方便。

* **日誌與除錯：** 在整合架構下運行，多個模組串聯，建議加入**日誌紀錄**（logging）。例如在各測試開始時記錄「User X 開始 Y 測試」，結束時記錄「完成Y測試用時 Z 秒」等資訊到控制台或日誌檔。如此即使某處出錯，也容易追蹤是哪一個測試環節問題。開發期間可開啟除錯模式（例如 `DEBUG=True` 顯示更多內部資訊），正式執行時再關閉，以免干擾使用者。

總括而言，按照以上建議進行模組化整合，可以使**程式架構清晰**且**易於維護**。單一 `.sh` 腳本串聯所有測試將大幅簡化執行流程，而統一的 JSON 資料儲存和色盲友善的介面設計則提高了系統的**可用性**與**可靠度**。在實作時多留意效能與使用者體驗的細節，將能滿足專案需求和教授的回饋要求，打造出良好且專業的手把測試應用程式。